/**
 *  @file   LArRecoND/include/LArSED.h
 *
 *  @brief  Header file defining the "SimEnergyDeposit" format.
 *          Based on autogenerated ROOT code with Pandora-style edits
 *
 *  $Log: $
 */
#ifndef PANDORA_LAR_SED_H
#define PANDORA_LAR_SED_H 1

#include "TChain.h"
#include "TFile.h"
#include "TROOT.h"

// Header file for the classes stored in the TTree if any.
#include <vector>

namespace lar_nd_reco
{

class LArSED
{
public:
    /**
     *  @brief  Constructor requiring TTree pointer
     *
     *  @param  tree The TTree pointer
     */
    LArSED(TTree *tree = nullptr);

    /**
     *  @brief  Destructor
     */
    virtual ~LArSED();

    /**
     *  @brief  Get the corresponding data entry
     *
     *  @param  entry The entry integer index
     *
     *  @return Total number of bytes read
     */
    virtual Int_t GetEntry(Long64_t entry);

    /**
     *  @brief  Initialise using the input TTree
     *
     *  @param  tree The input TTree
     */
    virtual void Init(TTree *tree);

    TTree *m_fChain;  ///< pointer to the analyzed TTree or TChain
    Int_t m_fCurrent; ///< current Tree number in a TChain

    // Declaration of leaf types
    Int_t m_run;
    Int_t m_subrun;
    Int_t m_event;
    std::vector<int> *m_nuPDG = nullptr;
    std::vector<int> *m_ccnc = nullptr;
    std::vector<int> *m_mode = nullptr;
    std::vector<float> *m_enu = nullptr;
    std::vector<float> *m_Q2 = nullptr;
    std::vector<float> *m_W = nullptr;
    std::vector<float> *m_X = nullptr;
    std::vector<float> *m_Y = nullptr;
    std::vector<int> *m_hitnuc = nullptr;
    std::vector<int> *m_target = nullptr;
    std::vector<float> *m_nuvtxx = nullptr;
    std::vector<float> *m_nuvtxy = nullptr;
    std::vector<float> *m_nuvtxz = nullptr;
    std::vector<float> *m_nu_dcosx = nullptr;
    std::vector<float> *m_nu_dcosy = nullptr;
    std::vector<float> *m_nu_dcosz = nullptr;
    std::vector<float> *m_lep_mom = nullptr;
    std::vector<float> *m_lep_dcosx = nullptr;
    std::vector<float> *m_lep_dcosy = nullptr;
    std::vector<float> *m_lep_dcosz = nullptr;
    std::vector<float> *m_t0 = nullptr;
    std::vector<int> *m_mcp_id = nullptr;
    std::vector<int> *m_mcp_mother = nullptr;
    std::vector<int> *m_mcp_pdg = nullptr;
    std::vector<int> *m_mcp_nuid = nullptr;
    std::vector<float> *m_mcp_energy = nullptr;
    std::vector<float> *m_mcp_px = nullptr;
    std::vector<float> *m_mcp_py = nullptr;
    std::vector<float> *m_mcp_pz = nullptr;
    std::vector<float> *m_mcp_startx = nullptr;
    std::vector<float> *m_mcp_starty = nullptr;
    std::vector<float> *m_mcp_startz = nullptr;
    std::vector<float> *m_mcp_endx = nullptr;
    std::vector<float> *m_mcp_endy = nullptr;
    std::vector<float> *m_mcp_endz = nullptr;
    std::vector<float> *m_sed_startx = nullptr;
    std::vector<float> *m_sed_starty = nullptr;
    std::vector<float> *m_sed_startz = nullptr;
    std::vector<float> *m_sed_endx = nullptr;
    std::vector<float> *m_sed_endy = nullptr;
    std::vector<float> *m_sed_endz = nullptr;
    std::vector<float> *m_sed_energy = nullptr;
    std::vector<int> *m_sed_id = nullptr;
    std::vector<int> *m_sed_pdg = nullptr;
    std::vector<std::string> *m_sed_det = nullptr;

    // List of branches
    TBranch *m_b_run = nullptr;
    TBranch *m_b_subrun = nullptr;
    TBranch *m_b_event = nullptr;
    TBranch *m_b_nuPDG = nullptr;
    TBranch *m_b_ccnc = nullptr;
    TBranch *m_b_mode = nullptr;
    TBranch *m_b_enu = nullptr;
    TBranch *m_b_Q2 = nullptr;
    TBranch *m_b_W = nullptr;
    TBranch *m_b_X = nullptr;
    TBranch *m_b_Y = nullptr;
    TBranch *m_b_hitnuc = nullptr;
    TBranch *m_b_target = nullptr;
    TBranch *m_b_nuvtxx = nullptr;
    TBranch *m_b_nuvtxy = nullptr;
    TBranch *m_b_nuvtxz = nullptr;
    TBranch *m_b_nu_dcosx = nullptr;
    TBranch *m_b_nu_dcosy = nullptr;
    TBranch *m_b_nu_dcosz = nullptr;
    TBranch *m_b_lep_mom = nullptr;
    TBranch *m_b_lep_dcosx = nullptr;
    TBranch *m_b_lep_dcosy = nullptr;
    TBranch *m_b_lep_dcosz = nullptr;
    TBranch *m_b_t0 = nullptr;
    TBranch *m_b_mcp_id = nullptr;
    TBranch *m_b_mcp_mother = nullptr;
    TBranch *m_b_mcp_pdg = nullptr;
    TBranch *m_b_mcp_nuid = nullptr;
    TBranch *m_b_mcp_energy = nullptr;
    TBranch *m_b_mcp_px = nullptr;
    TBranch *m_b_mcp_py = nullptr;
    TBranch *m_b_mcp_pz = nullptr;
    TBranch *m_b_mcp_startx = nullptr;
    TBranch *m_b_mcp_starty = nullptr;
    TBranch *m_b_mcp_startz = nullptr;
    TBranch *m_b_mcp_endx = nullptr;
    TBranch *m_b_mcp_endy = nullptr;
    TBranch *m_b_mcp_endz = nullptr;
    TBranch *m_b_sed_startx = nullptr;
    TBranch *m_b_sed_starty = nullptr;
    TBranch *m_b_sed_startz = nullptr;
    TBranch *m_b_sed_endx = nullptr;
    TBranch *m_b_sed_endy = nullptr;
    TBranch *m_b_sed_endz = nullptr;
    TBranch *m_b_sed_energy = nullptr;
    TBranch *m_b_sed_id = nullptr;
    TBranch *m_b_sed_pdg = nullptr;
    TBranch *m_b_sed_det = nullptr;
};

//------------------------------------------------------------------------------------------------------------------------------------------

LArSED::LArSED(TTree *tree) : m_fChain(nullptr)
{
    // if parameter tree is not specified (or zero), connect the file
    // used to generate this class and read the Tree.
    if (tree == nullptr)
    {
        TFile *f = dynamic_cast<TFile *>(gROOT->GetListOfFiles()->FindObject("simdump.root"));
        if (!f || !f->IsOpen())
        {
            f = new TFile("simdump.root");
        }
        TDirectory *dir = dynamic_cast<TDirectory *>(f->Get("simdump.root:/simdump"));
        dir->GetObject("ndsim", tree);
    }
    Init(tree);
}

//------------------------------------------------------------------------------------------------------------------------------------------

LArSED::~LArSED()
{
    if (!m_fChain)
        return;
    delete m_fChain->GetCurrentFile();
}

//------------------------------------------------------------------------------------------------------------------------------------------

Int_t LArSED::GetEntry(Long64_t entry)
{
    // Read contents of entry.
    if (!m_fChain)
        return 0;
    return m_fChain->GetEntry(entry);
}

//------------------------------------------------------------------------------------------------------------------------------------------

void LArSED::Init(TTree *tree)
{
    // The Init() function is called when the selector needs to initialize
    // a new tree or chain. Typically here the branch addresses and branch
    // pointers of the tree will be set.
    // It is normally not necessary to make changes to the generated
    // code, but the routine can be extended by the user if needed.
    // Init() will be called many times when running on PROOF
    // (once per file to be processed).

    // Set branch addresses and branch pointers
    if (!tree)
        return;
    m_fChain = tree;
    m_fCurrent = -1;
    m_fChain->SetMakeClass(1);

    m_fChain->SetBranchAddress("run", &m_run, &m_b_run);
    m_fChain->SetBranchAddress("subrun", &m_subrun, &m_b_subrun);
    m_fChain->SetBranchAddress("event", &m_event, &m_b_event);
    m_fChain->SetBranchAddress("nuPDG", &m_nuPDG, &m_b_nuPDG);
    m_fChain->SetBranchAddress("ccnc", &m_ccnc, &m_b_ccnc);
    m_fChain->SetBranchAddress("mode", &m_mode, &m_b_mode);
    m_fChain->SetBranchAddress("enu", &m_enu, &m_b_enu);
    m_fChain->SetBranchAddress("Q2", &m_Q2, &m_b_Q2);
    m_fChain->SetBranchAddress("W", &m_W, &m_b_W);
    m_fChain->SetBranchAddress("X", &m_X, &m_b_X);
    m_fChain->SetBranchAddress("Y", &m_Y, &m_b_Y);
    m_fChain->SetBranchAddress("hitnuc", &m_hitnuc, &m_b_hitnuc);
    m_fChain->SetBranchAddress("target", &m_target, &m_b_target);
    m_fChain->SetBranchAddress("nuvtxx", &m_nuvtxx, &m_b_nuvtxx);
    m_fChain->SetBranchAddress("nuvtxy", &m_nuvtxy, &m_b_nuvtxy);
    m_fChain->SetBranchAddress("nuvtxz", &m_nuvtxz, &m_b_nuvtxz);
    m_fChain->SetBranchAddress("nu_dcosx", &m_nu_dcosx, &m_b_nu_dcosx);
    m_fChain->SetBranchAddress("nu_dcosy", &m_nu_dcosy, &m_b_nu_dcosy);
    m_fChain->SetBranchAddress("nu_dcosz", &m_nu_dcosz, &m_b_nu_dcosz);
    m_fChain->SetBranchAddress("lep_mom", &m_lep_mom, &m_b_lep_mom);
    m_fChain->SetBranchAddress("lep_dcosx", &m_lep_dcosx, &m_b_lep_dcosx);
    m_fChain->SetBranchAddress("lep_dcosy", &m_lep_dcosy, &m_b_lep_dcosy);
    m_fChain->SetBranchAddress("lep_dcosz", &m_lep_dcosz, &m_b_lep_dcosz);
    m_fChain->SetBranchAddress("t0", &m_t0, &m_b_t0);
    m_fChain->SetBranchAddress("mcp_id", &m_mcp_id, &m_b_mcp_id);
    m_fChain->SetBranchAddress("mcp_mother", &m_mcp_mother, &m_b_mcp_mother);
    m_fChain->SetBranchAddress("mcp_pdg", &m_mcp_pdg, &m_b_mcp_pdg);
    m_fChain->SetBranchAddress("mcp_nuid", &m_mcp_nuid, &m_b_mcp_nuid);
    m_fChain->SetBranchAddress("mcp_energy", &m_mcp_energy, &m_b_mcp_energy);
    m_fChain->SetBranchAddress("mcp_px", &m_mcp_px, &m_b_mcp_px);
    m_fChain->SetBranchAddress("mcp_py", &m_mcp_py, &m_b_mcp_py);
    m_fChain->SetBranchAddress("mcp_pz", &m_mcp_pz, &m_b_mcp_pz);
    m_fChain->SetBranchAddress("mcp_startx", &m_mcp_startx, &m_b_mcp_startx);
    m_fChain->SetBranchAddress("mcp_starty", &m_mcp_starty, &m_b_mcp_starty);
    m_fChain->SetBranchAddress("mcp_startz", &m_mcp_startz, &m_b_mcp_startz);
    m_fChain->SetBranchAddress("mcp_endx", &m_mcp_endx, &m_b_mcp_endx);
    m_fChain->SetBranchAddress("mcp_endy", &m_mcp_endy, &m_b_mcp_endy);
    m_fChain->SetBranchAddress("mcp_endz", &m_mcp_endz, &m_b_mcp_endz);
    m_fChain->SetBranchAddress("sed_startx", &m_sed_startx, &m_b_sed_startx);
    m_fChain->SetBranchAddress("sed_starty", &m_sed_starty, &m_b_sed_starty);
    m_fChain->SetBranchAddress("sed_startz", &m_sed_startz, &m_b_sed_startz);
    m_fChain->SetBranchAddress("sed_endx", &m_sed_endx, &m_b_sed_endx);
    m_fChain->SetBranchAddress("sed_endy", &m_sed_endy, &m_b_sed_endy);
    m_fChain->SetBranchAddress("sed_endz", &m_sed_endz, &m_b_sed_endz);
    m_fChain->SetBranchAddress("sed_energy", &m_sed_energy, &m_b_sed_energy);
    m_fChain->SetBranchAddress("sed_id", &m_sed_id, &m_b_sed_id);
    m_fChain->SetBranchAddress("sed_pdg", &m_sed_pdg, &m_b_sed_pdg);
    m_fChain->SetBranchAddress("sed_det", &m_sed_det, &m_b_sed_det);
}

} // namespace lar_nd_reco

#endif
